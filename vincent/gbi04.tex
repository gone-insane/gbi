\include{header}
\subtitle{Foliensatz 4}
\date{15. November 2012}

\begin{document}

\begin{frame}
    \titlepage
\end{frame}

\begin{frame}{Outline/Gliederung}
    \tableofcontents
\end{frame}

\section{Division mit Rest}

\begin{frame}{Division mit Rest}
    \begin{block}{Definition}
        \begin{align*}
            &\forall x \in \mathbb{N}_0, \forall y \in \mathbb{N}_+:\\
            &x = y\cdot\left( x \div2 y\right) + \left( x\mod y\right)
        \end{align*}
        Hierbei ist $\div2$ die Ganzzahldivision ohne Rest.
    \end{block}
    \pause
    \begin{exampleblock}{Beispiel}
        Den Rest $a$ der Ganzzahldivision erhält man also mit $a = x \mod y$:
        \begin{align*}
            1 = 4 \mod 3
        \end{align*}
    \end{exampleblock}
\end{frame}

\begin{frame}{Division mit Rest}
    \begin{block}{Folgerung}
        Aus der Definition kann direkt geschlossen werden:
        \begin{align*}
            x \div2 y &\in \mathbb{N}_0\\
            x \mod y &\in \left\{ 0, \dots , y-1\right\}
        \end{align*}
    \end{block}
\end{frame}

\begin{frame}{Übung}
    % Diese Übung eignet sich sehr gut für ein Blitzlicht
    \begin{exampleblock}{mündlich}
        \begin{table}
            \begin{tabular}{llrr}
                \toprule
                $x$ & $y$ & $x \div2 y$ & $x \mod y$\\
                \midrule
                4 & 3 & \invisible<1>{1 & 1}\\
                2 & 1 & \invisible<1-2>{2 & 0}\\
                10 & 3 & \invisible<1-3>{3 & 1}\\
                8 & 3 & \invisible<1-4>{2 & 2}\\
                9 & 2 & \invisible<1-5>{4 & 1}\\
                4 & 3 & \invisible<1-6>{1 & 1}\\
                \bottomrule
            \end{tabular}
        \end{table}
        \pause\pause\pause\pause\pause\pause
    \end{exampleblock}
\end{frame}

\begin{frame}{Größter gemeinsamer Teiler}
    \begin{block}{Definition}
        Der größte gemeinsame Teiler zweier Zahlen ist die größtmögliche Zahl $m \in \mathbb{N}_0$, für die gilt:
        \begin{align*}
            a \div2 m = 0 \wedge b \ðiv m = 0
        \end{align*}
    \end{block}
    \pause
    \begin{exampleblock}{Bestimmung}
        Der größte gemeinsame Teiler kann mit Primfaktorzerlegung bestimmt werden:
        \begin{align*}
            a = 3528, b = 3780\\
            \Rightarrow a = 2^3\cdot 3^2\cdot 5^0 \cdot 7^2\\
            \Rightarrow b = 2^2\cdot 3^3\cdot 5^1\cdot 7^1\\
        \end{align*}
        Damit ist der \emph{ggT} $2^2 \cdot 3^2\cdot 5^0\cdot 7^1 = 252$
    \end{exampleblock}
\end{frame}

\begin{frame}{Größter gemeinsamer Teiler}
    \begin{exampleblock}{Programmierung}
        Die \emph{ggt}-Funktion lässt sich so programmieren:
        \begin{align*}
            \mathrm{ggt}\left( a, b\right) = \begin{cases} a &\text{falls } b = 0 \\ \mathrm{ggt}\left( b, a\mod b\right)& \end{cases}
        \end{align*}
    \end{exampleblock}
\end{frame}

\section{Algorithmen}

\begin{frame}{Algorithmen}
    \begin{block}{Eigenschaften}
        Ein Algorithmus\dots
        \begin{itemize}
            \item hat eine endliche Beschreibung, 
                \pause
            \item besteht aus elementaren Aussagen,
                \pause
            \item ist deterministisch,
                \pause
            \item gibt endliche Ausgabe auf endliche Eingabe aus,
                \pause
            \item hat endlich viele Schritte,
                \pause
            \item ist skalierbar
                \pause
            \item und ist nachvollziehbar
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}{Schleifen}
    \begin{block}{Arten}
        \begin{description}
            \item[while] Wiederholen, wenn eine Bedingung erfüllt ist.
                \pause
            \item[for] $n$-Mal wiederholen.
                \pause
            \item[do-while] Wiederholen, danach nochmal, wenn eine Bedingung erfüllt ist.
        \end{description}
    \end{block}
\end{frame}

\begin{frame}{Schleifen}
    \begin{exampleblock}{Beispiel 1}
        \begin{algorithm}
            \begin{algorithmic}
                \Require $x \in \mathbb{N}$
                \State $i \gets 0$
                \While{$x > 1$}
                    \State $x\gets x \div2 2$
                    \State $i\gets i + 1$
                \EndWhile
                \Ensure $i$
            \end{algorithmic}
        \end{algorithm}
    \end{exampleblock}
\end{frame}

\begin{frame}{Schleifen}
    \begin{exampleblock}{Beispiel 2}
        \begin{algorithm}
            \begin{algorithmic}
                \State $k \gets 0$
                \For{i}{0}{20}
                    \State $k\gets i$
                \EndFor
                \Ensure $k$
            \end{algorithmic}
        \end{algorithm}
    \end{exampleblock}
\end{frame}

\begin{frame}{Schleifen}
    \begin{exampleblock}{Beispiel 3}
        Gegeben sei ein Wort $w$ der Länge $\left| w\right| = n$. Das Array $W$ hat an $i$-ter Stelle den $i$-ten Buchstabe von $w$. $w$ ist $\epsilon$-frei.
        \begin{algorithm}
            \begin{algorithmic}
                \State $c \gets 0$
                \For{i}{0}{n-1}
                \State $c\gets \begin{cases} c + 1& \text{falls } W\left[ i\right] = x \\ c
                    &\text{sonst}\end{cases}$
                \EndFor
                \Ensure $c$
            \end{algorithmic}
        \end{algorithm}
    \end{exampleblock}
\end{frame}

\begin{frame}{Schleifen}
    \begin{exampleblock}{Übung 1, Winter 2008/2009}
        Es sei $A$ ein Alphabet.\\
        Schreiben Sie einen Algorithmus auf, der folgendes leistet: Als Eingaben erhält er ein Wort $w$ über $A$ und zwei Symbole $x \in A$ und $y \in A$. Am Ende soll eine Variable $r$ den Wert $0$ oder $1$ haben, und zwar soll gelten:\\
        \begin{align*}
            r = \begin{cases} 1 & \text{falls irgendwo in w direkt hintereinander erst $x$ dann $y$ vorkommt}\\ 0 &\text{sonst}\end{cases}
        \end{align*}
        Benutzen Sie zum Zugriff auf das $i$-te Symbol von $w$ die Schreibweise $w\left( i\right)$. Formulieren Sie den Algorithmus mit Hilfe einer for-Schleife.
    \end{exampleblock}
\end{frame}

\section{Schleifeninvarianzen}

\begin{frame}{Schleifeninvariante}
    \begin{block}{Definition}
        Eine Schleifeninvariante ist eine Eigenschaft einer Schleife, die bei jedem Schleifenzeitpunkt gültig ist.
    \end{block}
    \pause
    \begin{block}{Hä?}
        Eine Schleifeninvariante ist zum Beispiel
        \begin{itemize}
            \item ein Wertebereich für eine Variable oder
            \item ein Verhältnis zweiter Variablen.
        \end{itemize}
    \end{block}
\end{frame}
\begin{frame}{Schleifeninvarianzen}
    \begin{block}{Wofür?}
        Mit Schleifeninvarianten lassen sich Algorithmen überprüfen.
    \end{block}
    \pause
    \begin{block}{Wie?}
        Mit vollständiger Induktion :-)
    \end{block}
\end{frame}
\begin{frame}{Schleifeninvarianzen}
    \begin{exampleblock}{Beispiel}
        \begin{algorithm}
            \begin{algorithmic}
                \Require $a, b \in \mathbb{N}_0$
                \State $S \gets a$
                \State $Y \gets b$
                \For{i}{0}{b-1}
                    \State $ S \gets S - 1$
                    \State $Y \gets Y -1$
                \EndFor
                \Ensure $S$
            \end{algorithmic}
        \end{algorithm}
    \end{exampleblock}
    \pause
    \begin{exampleblock}{Übung}
        Algorithmus mit $a = 3$ und $b = 4$ ausprobieren und Werte für $S$ und $Y$ bei jedem Schleifendurchlauf finden.
    \end{exampleblock}
\end{frame}
\begin{frame}{Schleifeninvarianzen}
    \begin{exampleblock}{Winter 2008/2009}
        \begin{columns}
            \column{.60\textwidth}
                \begin{algorithm}
                    \begin{algorithmic}
                        \Require $a, b \in \mathbb{N}_0$
                        \State $X_0 \gets a$
                        \State $Y_0 \gets b$
                        \State $P_0 \gets 1$
                        \State $Z_0 \gets X_0 \mod 2$
                        \State $n \gets 1 + \left[ \log_2 a\right]$
                        \For{i}{0}{n-1}
                            \State $P_\mathrm{i+1} \gets P_\mathrm{i}\cdot Y_\mathrm{i}^\mathrm{Z_\mathrm{i}}$
                            \State $X_\mathrm{i+1} \gets X_\mathrm{i} \div 2$
                            \State $Y_\mathrm{i-1} \gets Y_\mathrm{i}^2$
                            \State $Z_\mathrm{i+1} \gets X_\mathrm{i+1} \mod 2$
                        \EndFor
                    \end{algorithmic}
                \end{algorithm}
            \column{.40\textwidth}
                Beweisen Sie durch vollständige Induktion über $i$ die Schleifeninvariante:
                \begin{align*}
                    \forall i \in \mathbb{N}_0: P_\mathrm{i} \cdot Y_\mathrm{i}^\mathrm{X_\mathrm{i}} = b^a
            \end{align*}
        \end{columns}
    \end{exampleblock}
\end{frame}

\end{document}
